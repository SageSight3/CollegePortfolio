Object subclass: #TraxCCodeGenerator	instanceVariableNames: 'stream tabCount cTypes binaryOperators unaryOperators'	classVariableNames: ''	poolDictionaries: ''	category: 'Trax-CCode Generator'!!TraxCCodeGenerator methodsFor: 'initialize-release' stamp: 'SA 12/5/2023 17:38'!initialize	super initialize.	tabCount := 0.	stream := WriteStream on: (String new: 1024).	cTypes := Dictionary new.	cTypes		at: '#' put: 'int';		at: '?' put: 'bool';		at: '"' put: 'std::string'.	binaryOperators := Dictionary new.	binaryOperators		at: '*' put: '*';		at: '/' put: '/';		at: 'rem' put: '%';		at: '+' put: '+';		at: '-' put: '-';		at: '>' put: '>';		at: '<' put: '<';		at: '=' put: '==';		at: 'and' put: '&&';		at: 'or' put: '||'.	unaryOperators := Dictionary new.	unaryOperators		at: 'not' put: '!!'.! !!TraxCCodeGenerator methodsFor: 'accessing' stamp: 'SA 12/5/2023 12:50'!sigil: aSigil to: aCType		cTypes at: '?' put: 'bool'.	cTypes at: '"' put: 'string'.	cTypes at: '#' put: 'int'.! !!TraxCCodeGenerator methodsFor: 'accessing' stamp: 'SA 12/4/2023 16:36'!stream	^ stream! !!TraxCCodeGenerator methodsFor: 'accessing' stamp: 'SA 12/4/2023 16:36'!stream: anObject	stream := anObject.! !!TraxCCodeGenerator methodsFor: 'accessing' stamp: 'SA 12/4/2023 16:36'!tabCount	^ tabCount! !!TraxCCodeGenerator methodsFor: 'accessing' stamp: 'SA 12/4/2023 16:36'!tabCount: anObject	tabCount := anObject.! !!TraxCCodeGenerator methodsFor: 'formatting' stamp: 'SA 12/5/2023 11:42'!indent	self stream tab: self tabCount! !!TraxCCodeGenerator methodsFor: 'formatting' stamp: 'SA 12/5/2023 11:43'!tabIn	tabCount := tabCount + 1! !!TraxCCodeGenerator methodsFor: 'formatting' stamp: 'SA 12/5/2023 11:43'!tabOut	tabCount := tabCount - 1! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 15:54'!visitTraxArguments: aTraxArguments 		self stream nextPutAll: '('.	aTraxArguments arguments		do: [:each | each accept: self]		separatedBy: [self stream nextPutAll: ', '].	self stream nextPutAll: ')'! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 13:28'!visitTraxAssignment: aTraxAssignment 	self indent.	self stream		nextPutAll: aTraxAssignment name;		nextPutAll: ' = '.	aTraxAssignment expression accept: self.	self stream		nextPutAll: ';';		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 17:09'!visitTraxBinaryExpression: aTraxBinaryExpression 		aTraxBinaryExpression arg1 accept: self.	aTraxBinaryExpression op accept: self.	aTraxBinaryExpression arg2 accept: self.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 17:24'!visitTraxBinaryOp: aTraxBinaryOp 		self stream 		space;		nextPutAll: (binaryOperators at: aTraxBinaryOp operation);		space! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:56'!visitTraxBody: aTraxBody 		self indent.	self stream 		nextPutAll: '//body';		cr.	self tabIn.	aTraxBody statement accept: self.	self tabOut.	self indent.	self stream		nextPutAll: '//end of body';		cr;		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 14:47'!visitTraxCompoundStatement: aTraxCompoundStatement 	aTraxCompoundStatement statements		do: [:each | each accept: self].! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:32'!visitTraxFunction: aTraxFunction 	self stream		nextPutAll: (cTypes at: aTraxFunction type sigil);		nextPutAll: ' _';		nextPutAll: aTraxFunction name.	aTraxFunction parameters accept: self.	self stream		nextPutAll: ' {';		cr;		nextPutAll: '		';		nextPutAll: (cTypes at: aTraxFunction type sigil);		nextPutAll: ' ';		nextPutAll: aTraxFunction name;		nextPutAll: ';';		cr.	aTraxFunction variables accept: self.	self stream		cr.	aTraxFunction body accept: self.	self stream		nextPutAll: '		return ';		nextPutAll: aTraxFunction name;		nextPutAll: ';';		cr;		nextPutAll: '}';		cr;		cr.	! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:14'!visitTraxFunctionCall: aTraxFunctionCall 		self stream		nextPutAll: ' _';		nextPutAll: aTraxFunctionCall name.	aTraxFunctionCall arguments accept: self.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 16:20'!visitTraxGrouping: aTraxGrouping 	self stream nextPutAll: '('.	aTraxGrouping expression accept: self.	self stream nextPutAll: ')'.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 16:26'!visitTraxIfThen: aTraxIfThen 		self indent.	self stream 		nextPutAll: 'if ('.	aTraxIfThen condition accept: self.	self stream 		nextPutAll: ') {'; 		cr.	self tabIn.	aTraxIfThen trueStatement accept: self.	self tabOut.	self indent.	self stream		nextPutAll: '}';		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 16:43'!visitTraxIfThenElse: aTraxIfThenElse 	self indent.	self stream 		nextPutAll: 'if ('.	aTraxIfThenElse condition accept: self.	self stream 		nextPutAll: ') {'; 		cr.	self tabIn.	aTraxIfThenElse trueStatement accept: self.	self tabOut.	self indent.	self stream		nextPutAll: '} ';		nextPutAll: 'else {';		cr.	self tabIn.	aTraxIfThenElse falseStatement accept: self.	self tabOut.	self indent.	self stream		nextPutAll: '}';		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 13:23'!visitTraxLiteralBoolean: aTraxLiteralBoolean 		self stream nextPutAll: aTraxLiteralBoolean value asString! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 13:23'!visitTraxLiteralInteger: aTraxLiteralInteger 		self stream nextPutAll: aTraxLiteralInteger value asString! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 13:24'!visitTraxLiteralString: aTraxLiteralString 		self stream		nextPutAll: '"';		nextPutAll: aTraxLiteralString value;		nextPutAll: '"'! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:53'!visitTraxMethods: aTraxMethods	aTraxMethods methods isEmpty ifTrue: [^self].	self indent.	self stream 		nextPutAll: '//methods';		cr;		cr.	self tabIn.	aTraxMethods methods		do:[:each | each accept: self].	self tabOut.				! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:16'!visitTraxNewline: aTraxNewline 		self indent.	self stream		nextPutAll: 'std::cout << std::endl;';		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 12:15'!visitTraxNullStatement: aTraxNullStatement 		^self! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:16'!visitTraxOutput: aTraxOutput 		self indent.	self stream 		nextPutAll: 'std::cout << '.	aTraxOutput expression accept: self.	self stream 		nextPutAll: ';';		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 14:27'!visitTraxParameter: aTraxParameter 	self stream		nextPutAll: (cTypes at: aTraxParameter type sigil); 			nextPutAll: ' ';		nextPutAll: aTraxParameter name.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 14:17'!visitTraxParameters: aTraxParameters 	self stream nextPutAll: '('.	aTraxParameters parameters		do: [:each | each accept: self]		separatedBy: [self stream nextPutAll: ', '].	self stream nextPutAll: ')'.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:26'!visitTraxProcedure: aTraxProcedure 	self stream		nextPutAll: 'void ';		nextPutAll: aTraxProcedure name.	aTraxProcedure parameters accept: self.	self stream		nextPutAll: ' {';		cr.	aTraxProcedure variables accept: self.	self stream		cr.	aTraxProcedure body accept: self.	self stream		nextPutAll: '}';		cr;		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 15:57'!visitTraxProcedureCall: aTraxProcedureCall 	self indent.	self stream nextPutAll: aTraxProcedureCall name.	aTraxProcedureCall arguments accept: self.	self stream		nextPutAll: ';';		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 13:35'!visitTraxProgram: aTraxProgram 	self stream 		nextPutAll: '#include <iostream>';		cr;		cr.	aTraxProgram variables accept: self.	self stream		cr.	aTraxProgram methods accept: self.	self stream		nextPutAll: 'int main(int argc, char* argv[]) {';		cr.	aTraxProgram body accept: self.	self stream 		cr;		nextPutAll: '}'.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 17:31'!visitTraxUnaryExpression: aTraxUnaryExpression 		self stream		nextPutAll: (unaryOperators at: aTraxUnaryExpression op).	aTraxUnaryExpression expression accept: self.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:50'!visitTraxVariableDeclaration: aTraxVariableDeclaration 		self indent.	self stream		nextPutAll: (cTypes at: aTraxVariableDeclaration type sigil); 			nextPutAll: ' ';		nextPutAll: aTraxVariableDeclaration name;		nextPutAll: ';';		cr.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 14:29'!visitTraxVariableReference: aTraxVariableReference 	self stream 		nextPutAll: aTraxVariableReference name.! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/6/2023 10:52'!visitTraxVariables: aTraxVariables 	aTraxVariables variables isEmpty ifTrue: [^self].	self indent.	self stream nextPutAll: '//variables';	cr;	cr.	self tabIn.	aTraxVariables variables		do:[:each | each accept: self].	self tabOut.				! !!TraxCCodeGenerator methodsFor: 'visiting' stamp: 'SA 12/5/2023 17:53'!visitTraxWhileLoop: aTraxWhileLoop 	self indent.	self stream nextPutAll: 'while ('.	aTraxWhileLoop condition accept: self.	self stream nextPutAll: ') {'; cr.	self tabIn.	aTraxWhileLoop statement accept: self.	self tabOut.	self indent.	self stream		nextPutAll: '}';		 cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TraxCCodeGenerator class	instanceVariableNames: ''!!TraxCCodeGenerator class methodsFor: 'code-generating' stamp: 'SA 12/4/2023 16:44'!generate: aProgramString	| generator ast |	generator := self new.	ast := TraxParser parse: aProgramString.	ast accept: generator.	^generator stream contents! !TestCase subclass: #TraxCCodeGeneratorTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Trax-CCode Generator'!!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 17:40'!testFactorial		| cCode |	cCode := TraxCCodeGenerator generate: self factorialProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 16:28'!testIfThenElseProgram		| cCode |	cCode := TraxCCodeGenerator generate: self IfThenElseProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 16:08'!testIfThenProgram		| cCode |	cCode := TraxCCodeGenerator generate: self IfThenProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/4/2023 16:48'!testNanoProgram	| cCode |	cCode := TraxCCodeGenerator generate: self nanoProgram.	cCode inspect.! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 10:34'!testOperatorProgram	| cCode |	cCode := TraxCCodeGenerator generate: self operatorProgram.	cCode inspect.! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 17:08'!testOps		| cCode |	cCode := TraxCCodeGenerator generate: self OpsProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 10:34'!testProcedureProgram	| cCode |	cCode := TraxCCodeGenerator generate: self procedureProgram.	cCode inspect.! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 15:28'!testProcsFuncsCallProgram		| cCode |	cCode := TraxCCodeGenerator generate: self procsFuncsCallProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 14:09'!testProcsFuncsOutProgram		| cCode |	cCode := TraxCCodeGenerator generate: self procsFuncsOutProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 20:50'!testUndeclaredProcErrorProgram		| cCode |	cCode := TraxCCodeGenerator generate: self undeclaredProcErrorProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 13:08'!testVarAssignmentLapProgram		| cCode |	cCode := TraxCCodeGenerator generate: self varAssignmentLapProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 10:34'!testVariablesProgram	| cCode |	cCode := TraxCCodeGenerator generate: self variablesProgram.	cCode inspect.! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 12:24'!testVarsProgram		| cCode |	cCode := TraxCCodeGenerator generate: self varsProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'running' stamp: 'SA 12/5/2023 17:50'!testWhileLoop		| cCode |	cCode := TraxCCodeGenerator generate: self WhileLoopProgram.	cCode inspect.	! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/5/2023 16:28'!IfThenElseProgram^'ready IfThenElseProgramset	isTrue | ?go	begin		isTrue <- true		if (isTrue) then			out "hi"		else			out "howdy"		if isTrue then			begin				if isTrue then					lap				else					isTrue <- false				out "howdy"			end	end'	! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/5/2023 16:25'!IfThenProgram^'ready IfThenProgramset	isTrue | ?go	begin		isTrue <- true		if (isTrue) then			out "hi"		if isTrue then			begin				if isTrue then					lap				out "howdy"			end	end'	! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/6/2023 10:34'!OpsProgram^'ready ArithmeticRelationalOpsProgramset	x|#	y|#	z|#	msg|"	success|?
	reply|"trax	ready opTest(num|#, d|#, a|#) |?	set		sum|#		product|#		quotient|#		difference|#		fraction|#		group|#	go		begin			sum <- num + d			difference <- sum - num			quotient <- difference / sum			product <- a * d			fraction <- sum rem product			group <- a * d + num / a - ((d * num) / a) rem (product - sum - quotient rem product)					if (sum < d) then				out fraction			if ((sum < d) and  (d > product)) then				out "fly"			if ((sum - num) = d) then				out msg			if ((reply > msg) or (group > fraction)) then				out reply							if (((sum = group) and (group + 6 < product)) or (((group + 6) = difference) and (difference > sum))) then				opTest <- true			else				begin					opTest <- false				end		endgo	begin		x <- 7		y <- 9		z <- 22		msg <- "u smel"		reply <- "no u"		success <- opTest(x, y, z)		if (not(success)) then			out "howdy"	end'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/5/2023 17:49'!WhileLoopProgram	^'ready WhileLoop	go		begin			while true do				out "nearly there"					while (false) do				begin					out "so close"					out "i can taste it"				end		end'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/5/2023 17:38'!factorialProgram	^'ready factorial	set		msg | "	trax		ready factorial(n|#) | #    		go        			if n = 0 then            				factorial <- 1       			else            				factorial <- n * factorial(n - 1)	go		begin        			msg <- "Factorial 5 is "        			out msg        			out factorial(5)        			lap		end'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/4/2023 16:47'!nanoProgram	^'ready nano go'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/8/2023 10:33'!operatorProgram	^'ready operatorTestgo    begin        if (9 > 7) and ((not (true = false)) or ("hello" < "abc")) then            out (((7 + 3)*(8 - 2)) rem 7) / 2    end'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/8/2023 10:33'!procedureProgram	^'ready procTesttrax    ready sayHello()    go        out "Hello, World!!"        ready countdown(count|#, message|")    set         counter|#    go        begin            counter <- count            while counter > 0 do            begin                counter <- counter - 1                out counter            end            out message            lap        end                go    begin        sayHello()        countdown(10, "Blastoff!!")    end'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/6/2023 10:40'!procsFuncsCallProgram^'ready procsFuncsCallProgramset	in | #	count | #	hi | ?trax	ready betCount(input | #) |#	go		betCount <- input			ready printCount()	go		begin			out count			lap		end		ready multiArg(aString | ", aBool | ?)	go		begin			out aString			lap			out aBool		end		go	begin		in <- 5		hi <-  true		count <- betCount (in)		printCount()		multiArg("howdy", hi)	end'		! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/5/2023 14:09'!procsFuncsOutProgram	^'ready procsFuncsOut trax ready proc() go out "hi" ready procArg(aString|") go begin out aString lap end ready func(x|#, y|#) |# go begin out x lap out y lap func <- x end go'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/8/2023 20:49'!undeclaredProcErrorProgram	^'ready nano	set		gun | "		num | #	trax		ready stirrups()		go				ready duel(hit | ?)		go				ready ammo() |"		go			ammo <- "This town aint big enough for the both of us"				go		begin			stirrups()			duel(4)			gun <- urgonnadie()			gun <- ammo()			num <- ammo()			gun <- "death"			duel(gun)			hi()			howdy()		end'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/6/2023 10:45'!varAssignmentLapProgram	^'ready varAssignmentLap set num|# msg|" conditional|? go begin num<-9 msg<-"howdy" conditional<-true lap end'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/8/2023 10:33'!variablesProgram	^'ready variables	set		answer | #		msg | "		isIt | ?	go		begin			answer <- 42			out answer lap			msg <- "Hello, World!!"			out msg lap			isIt <- true			out isIt lap		end'! !!TraxCCodeGeneratorTestCase methodsFor: 'accessing' stamp: 'SA 12/5/2023 12:28'!varsProgram	^'ready vars set num|# msg|" conditional|? go'! !