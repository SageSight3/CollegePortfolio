Object subclass: #TraxSemanticAnalyzer	instanceVariableNames: 'program env binaryOps errors'	classVariableNames: ''	poolDictionaries: ''	category: 'Trax-TraxSemanticAnalyzer'!!TraxSemanticAnalyzer methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:19'!binaryOps	^ binaryOps! !!TraxSemanticAnalyzer methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:19'!binaryOps: anObject	binaryOps := anObject.! !!TraxSemanticAnalyzer methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:19'!env	^ env! !!TraxSemanticAnalyzer methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:19'!env: anObject	env := anObject.! !!TraxSemanticAnalyzer methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:19'!errors	^ errors! !!TraxSemanticAnalyzer methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:19'!errors: anObject	errors := anObject.! !!TraxSemanticAnalyzer methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:19'!program	^ program! !!TraxSemanticAnalyzer methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:19'!program: anObject	program := anObject.! !!TraxSemanticAnalyzer methodsFor: 'initialize-release' stamp: 'SA 12/7/2023 10:17'!initialize	super initialize.	env := TraxEnvironment new.	errors := OrderedCollection new.	binaryOps := IdentityDictionary new		at: #= put: [:arg1 :arg2 | arg1 = arg2];		at: #< put: [:arg1 :arg2 | arg1 < arg2];		at: #> put: [:arg1 :arg2 | arg1 > arg2];		at: #* put: [:arg1 :arg2 | arg1 * arg2];		at: #/ put: [:arg1 :arg2 | arg1 / arg2];		at: #rem put: [:arg1 :arg2 | arg1 \\ arg2];		at: #+ put: [:arg1 :arg2 | arg1 + arg2];		at: #- put: [:arg1 :arg2 | arg1 - arg2];		at: #and put: [:arg1 :arg2 | arg1 and: [arg2]];		at: #or put: [:arg1 :arg2 | arg1 or: [arg2]];		yourself.! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 21:18'!BROKENvisitTraxFunctionCall: aTraxFunctionCall 	| funcName func args returnVar |	funcName := aTraxFunctionCall name.					[func:= self env 		getMethod: funcName]			on: TraxError			do:[:ex | self errors add: ex].	args := aTraxFunctionCall arguments accept: self.	func isNil ifTrue: [^nil].	returnVar := TraxVariable type: func type.	self env activate.	[self bind: func parameters arguments: args.]		on: TraxError		do:[:ex | self errors add: ex].	self env deactivate.! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 18:17'!visitTraxArguments: aTraxArguments 	^aTraxArguments arguments 		collect: [:each | each accept: self].! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/11/2023 15:51'!visitTraxArithmeticOp: aTraxArithmeticOp 		^[:arg1 :arg2 |	arg1 isInteger ifFalse: [self errors add: (TraxError new messageText: 'ArithmeticError: ArgMustBeInt')].	arg2 isInteger ifFalse: [self errors add: (TraxError new messageText: 'ArithmeticError: ArgMustBeInt')].	0]! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 10:48'!visitTraxAssignment: aTraxAssignment 		| aVar aVal |	[aVar :=(self env 		getVariable: aTraxAssignment name)]			on: TraxError			do:[:ex | self errors add: ex].	aVal := aTraxAssignment expression accept: self.	aVar isNil ifTrue: [^nil].			[aVar set: aVal]		on: TraxError		do:[:ex | self errors add: ex].			! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/12/2023 11:28'!visitTraxBinaryExpression: aTraxBinaryExpression 		| answer |	answer := (aTraxBinaryExpression op accept: self) 		value: (aTraxBinaryExpression arg1 accept: self)		value: (aTraxBinaryExpression arg2 accept: self).	^answer! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/7/2023 10:28'!visitTraxBody: aTraxBody 	aTraxBody statement accept: self! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/7/2023 10:46'!visitTraxCompoundStatement: aTraxCompoundStatement 	aTraxCompoundStatement statements		do: [:each | each accept: self]! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 16:30'!visitTraxFunction: aTraxFunction 	[self env		declare: aTraxFunction name		method: aTraxFunction]			on: TraxError			do:[:ex | self errors add: ex].! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/11/2023 14:58'!visitTraxGrouping: aTraxGrouping 	^aTraxGrouping expression accept: self! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/12/2023 10:57'!visitTraxIfThen: aTraxIfThen 		| condition |	condition := aTraxIfThen condition.	condition accept: self.	"condition isBoolean ifFalse: [self errors add: (TraxError new messageText: 'IfThenConditionMustBeBoolean')]"	[TraxBooleanType default checkType: condition]		on: TraxError		do: [:ex | self errors add: ex]! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/12/2023 10:57'!visitTraxIfThenElse: aTraxIfThenElse 		| condition |	condition := aTraxIfThenElse condition.	condition accept: self.	"condition isBoolean ifFalse: [self errors add: (TraxError new messageText: 'IfElseConditionMustBeBoolean')]"	[TraxBooleanType default checkType: condition]		on: TraxError		do: [:ex | self errors add: ex]! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/12/2023 10:59'!visitTraxLiteralBoolean: aTraxLiteralBoolean	^false! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 10:48'!visitTraxLiteralInteger: aTraxLiteralInteger	^aTraxLiteralInteger value! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 10:49'!visitTraxLiteralString: aTraxLiteralInteger	^aTraxLiteralInteger value! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/12/2023 10:17'!visitTraxLogicalOp: aTraxLogicalOp	^[:arg1 :arg2 |	arg1 isBoolean ifFalse: [self errors add: (TraxError new messageText: 'LogicError: ArgMustBeBool')].	arg2 isBoolean ifFalse: [self errors add: (TraxError new messageText: 'LogicError: ArgMustBeBool')].	true]! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/7/2023 10:28'!visitTraxMethods: aTraxMethods 		aTraxMethods methods		do: [:each | each accept: self]! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/7/2023 10:29'!visitTraxNullStatement: aTraxNullStatement 		"Default behavior is to do nothing."	! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/7/2023 10:47'!visitTraxOutput: aTraxOutput 	aTraxOutput expression accept: self! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 18:25'!visitTraxParameter: aTraxParameter 		^self visitTraxVariableDeclaration: aTraxParameter! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 16:29'!visitTraxProcedure: aTraxProcedure 	[self env		declare: aTraxProcedure name		method: aTraxProcedure]			on: TraxError			do:[:ex | self errors add: ex].! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/8/2023 18:28'!visitTraxProcedureCall: aTraxProcedureCall 	| procedureName proc args |	procedureName := aTraxProcedureCall name.					[proc := self env 		getMethod: procedureName]			on: TraxError			do:[:ex | self errors add: ex].	args := aTraxProcedureCall arguments accept: self.	proc isNil ifTrue: [^nil].	self env activate.	[self bind: proc parameters arguments: args.]		on: TraxError		do:[:ex | self errors add: ex].	self env deactivate.! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/7/2023 10:26'!visitTraxProgram: aTraxProgram 	aTraxProgram variables accept: self.	aTraxProgram methods accept: self.	aTraxProgram body accept: self.! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/11/2023 15:51'!visitTraxRelationalOp: aTraxRelationalOp	^[:arg1 :arg2 |	arg1 isInteger ifFalse: [self errors add: (TraxError new messageText: 'RelationError: ArgMustBeInt')].	arg2 isInteger ifFalse: [self errors add: (TraxError new messageText: 'RelationError: ArgMustBeInt')].	true]! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/12/2023 11:16'!visitTraxUnaryExpression: aTraxUnaryExpression 	^(aTraxUnaryExpression expression accept: self) not! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/7/2023 10:57'!visitTraxVariableDeclaration: aTraxVariableDeclaration 	| var |	var := TraxVariable type: aTraxVariableDeclaration type.	[self env		declare: aTraxVariableDeclaration name		variable: var]			on: TraxError			do:[:ex | self errors add: ex].	^var! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/12/2023 11:55'!visitTraxVariableReference: aTraxVariableReference 	| var |	var := [(self env getVariable: aTraxVariableReference name) get]		on: TraxError		do:[:ex | self errors add: ex].	"self halt."	^var! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/7/2023 10:28'!visitTraxVariables: aTraxVariables 	aTraxVariables variables		do: [:each | each accept: self]! !!TraxSemanticAnalyzer methodsFor: 'visiting' stamp: 'SA 12/12/2023 11:41'!visitTraxWhileLoop: aTraxWhileLoop		| condition |	condition := aTraxWhileLoop condition.	"self halt."	condition accept: self.	"condition isBoolean ifFalse: [self errors add: (TraxError new messageText: 'WhileConditionMustBeBoolean')]"	[TraxBooleanType default checkType: condition]		on: TraxError		do: [:ex | self errors add: ex]! !!TraxSemanticAnalyzer methodsFor: 'binding' stamp: 'SA 12/8/2023 18:21'!bind: parameters arguments: values 	| paramStream valueStream |	paramStream := ReadStream on: parameters parameters.	valueStream := ReadStream on: values.	[paramStream atEnd]		whileFalse:			[|param|			param := paramStream next accept: self.			param set: valueStream next]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TraxSemanticAnalyzer class	instanceVariableNames: ''!!TraxSemanticAnalyzer class methodsFor: 'analyzing' stamp: 'SA 12/7/2023 10:31'!analyze: aProgram	| ast analyst |	ast := TraxParser parse: aProgram.	analyst := self new.	analyst program: aProgram.	ast accept: analyst.	^analyst errors! !TestCase subclass: #TraxSemanticAnalyzerTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Trax-TraxSemanticAnalyzer'!!TraxSemanticAnalyzerTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 16:20'!testMultipleMethodError	| errors |	errors:= TraxSemanticAnalyzer analyze: self multipleMethodErrorProgram.	self assert: 1 equals: errors size.	self assert: (errors first class name = #TraxMultiplyDeclaredError).	errors inspect.! !!TraxSemanticAnalyzerTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 10:38'!testMultipleVariableError	| errors |	errors:= TraxSemanticAnalyzer analyze: self multipleVariableErrorProgram.	self assert: 1 equals: errors size.	self assert: (errors first class name = #TraxMultiplyDeclaredError).	errors inspect.! !!TraxSemanticAnalyzerTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 10:37'!testNano	| errors |	errors:= TraxSemanticAnalyzer analyze: self nanoProgram.	self assert: errors isEmpty.	errors inspect.! !!TraxSemanticAnalyzerTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 21:21'!testUndeclaredProcError	| errors |	errors:= TraxSemanticAnalyzer analyze: self undeclaredProcErrorProgram.	self assert: 4 equals: errors size.	errors inspect.! !!TraxSemanticAnalyzerTestCase methodsFor: 'running' stamp: 'SA 12/8/2023 10:49'!testUndeclaredVariableError	| errors |	errors:= TraxSemanticAnalyzer analyze: self undeclaredVariableErrorProgram.	self assert: 3 equals: errors size.	errors inspect.! !!TraxSemanticAnalyzerTestCase methodsFor: 'running' stamp: 'SA 12/12/2023 11:06'!testWhileIfNonBoolError	| errors |	errors:= TraxSemanticAnalyzer analyze: self whileIfNonBoolErrorProgram.	errors inspect.	self assert: 8 equals: errors size.! !!TraxSemanticAnalyzerTestCase methodsFor: 'accessing' stamp: 'SA 12/8/2023 11:00'!multipleMethodErrorProgram	^'ready nano	trax		ready hi()		go				ready hi() |"		go			go'! !!TraxSemanticAnalyzerTestCase methodsFor: 'accessing' stamp: 'SA 12/7/2023 10:35'!multipleVariableErrorProgram	^'ready nano	set		msg | "		msg | ?	go'	"To test code is syntactically correct, parse it by typing TraxParser parse: before the string, highlight whole method, and ctrl-i"! !!TraxSemanticAnalyzerTestCase methodsFor: 'accessing' stamp: 'SA 12/8/2023 10:59'!nanoProgram	^'ready nano go'! !!TraxSemanticAnalyzerTestCase methodsFor: 'accessing' stamp: 'SA 12/8/2023 21:23'!undeclaredProcErrorProgram	^'ready nano	set		gun | "	trax		ready stirrups()		go				ready duel(hit | ?)		go				go		begin			stirrups()			duel(4)			duel(true)			gun <- "death"			duel(gun)			hi()			howdy()		end'! !!TraxSemanticAnalyzerTestCase methodsFor: 'accessing' stamp: 'SA 12/8/2023 10:50'!undeclaredVariableErrorProgram	^'ready nano	set		val | #	go		begin			val <- true			out theAnswer			theAnswer <- 42		end'		"To test code is syntactically correct, parse it by typing TraxParser parse: before the string, highlight whole method, and ctrl-i"! !!TraxSemanticAnalyzerTestCase methodsFor: 'accessing' stamp: 'SA 12/12/2023 11:12'!whileIfNonBoolErrorProgram	^'ready nano 	set		nonBool | #		aBool | ?	go		begin			nonBool <- 3			aBool <- true						if aBool then				out "what"							if aBool then				out "what fancy"			else				out "this is sad"										while aBool do				out "woah"						if nonBool then				out "no"							if nonBool then				out "what fancy"			else				out "this is sad"							while nonBool do				out "sadge"			while (nonBool + 5) do				out "ew"							if (nonBool + 5) then				out "smells bad"			if (nonBool + 5) then				out "what fancy"			else				out "this is sad"							while (nonBool > 5) do				out "ew"							if (nonBool < 5) then				out "smells bad"			if (nonBool = 5) then				out "what fancy"			else				out "this is sad"							while (aBool or ((5 = 5)  and (nonBool < 5))) do				out "ew"							if (false and true) then				out "smells bad"			if (aBool or true) then				out "what fancy"			else				out "this is sad"			while (not(aBool or ((5 = 5)  and (nonBool < 5)))) do				out "ew"							if (not(false and true)) then				out "smells bad"			if (not(aBool or true)) then				out "what fancy"			else				out "this is sad"							aBool <- (5 or 6)		 end'! !